From 6cdf040453bdad146d5b820effc04f5ee469e9f9 Mon Sep 17 00:00:00 2001
From: Claude <noreply@anthropic.com>
Date: Wed, 19 Nov 2025 21:55:39 +0000
Subject: [PATCH 3/3] Use file-based block I/O instead of loading disk into
 memory

Changed disk image handling to keep the .2mg file open and seek/read/write
blocks on demand, rather than loading the entire disk into memory.

Benefits:
- Much faster startup for large disk images
- Lower memory usage
- Writes are immediately flushed to disk

This uses fseek() to position at the correct block offset and fread()/fwrite()
to transfer 512-byte blocks between the file and the 6502 memory.
---
 src/sim65/main.c | 73 +++++++++++++++++++++++++++++-------------------
 1 file changed, 44 insertions(+), 29 deletions(-)

diff --git a/src/sim65/main.c b/src/sim65/main.c
index b33f3c6e2..04ad829a1 100644
--- a/src/sim65/main.c
+++ b/src/sim65/main.c
@@ -66,9 +66,10 @@ const char* ProgramFile;
 /* Name of disk image file (.2mg format) */
 static const char* DiskImageFile = NULL;
 
-/* Disk image data (loaded from .2mg) */
-static unsigned char* DiskImage = NULL;
+/* Disk image file handle and metadata */
+static FILE* DiskImageHandle = NULL;
 static unsigned int DiskBlockCount = 0;
+static const unsigned int DiskHeaderSize = 64; /* .2mg header size */
 
 /* Set to True if CPU mode override is in effect. If set, the CPU is not read from the program file. */
 static bool CPUOverrideActive = false;
@@ -205,25 +206,23 @@ static void OptDisk (const char* Opt attribute ((unused)),
 
 
 static void LoadDiskImage (void)
-/* Load .2mg disk image into memory */
+/* Open .2mg disk image file and read header */
 {
-    FILE* F;
     unsigned char header[64];
     unsigned long diskSize;
-    size_t bytesRead;
 
     if (DiskImageFile == NULL) {
         return; /* No disk image specified */
     }
 
-    /* Open the disk image file */
-    F = fopen(DiskImageFile, "rb");
-    if (F == NULL) {
+    /* Open the disk image file for reading and writing */
+    DiskImageHandle = fopen(DiskImageFile, "r+b");
+    if (DiskImageHandle == NULL) {
         Error("Cannot open disk image '%s': %s", DiskImageFile, strerror(errno));
     }
 
     /* Read and validate .2mg header */
-    if (fread(header, 1, 64, F) != 64) {
+    if (fread(header, 1, 64, DiskImageHandle) != 64) {
         Error("'%s': Cannot read .2mg header", DiskImageFile);
     }
 
@@ -236,22 +235,9 @@ static void LoadDiskImage (void)
     diskSize = header[28] | (header[29] << 8) | (header[30] << 16) | (header[31] << 24);
     DiskBlockCount = diskSize / 512;
 
-    Print(stderr, 1, "Loading disk image '%s' (%u blocks)\n", DiskImageFile, DiskBlockCount);
+    Print(stderr, 1, "Opened disk image '%s' (%u blocks)\n", DiskImageFile, DiskBlockCount);
 
-    /* Allocate memory for disk image */
-    DiskImage = malloc(diskSize);
-    if (DiskImage == NULL) {
-        Error("Cannot allocate memory for disk image (%lu bytes)", diskSize);
-    }
-
-    /* Read disk data (header is already skipped, data starts at offset 64) */
-    bytesRead = fread(DiskImage, 1, diskSize, F);
-    if (bytesRead != diskSize) {
-        Error("'%s': Failed to read disk data (expected %lu bytes, got %lu)",
-              DiskImageFile, diskSize, (unsigned long)bytesRead);
-    }
-
-    fclose(F);
+    /* File remains open for block I/O operations */
 }
 
 
@@ -292,10 +278,11 @@ void HandleBlockIO (void)
     unsigned char command;
     unsigned int bufferAddr;
     unsigned int blockNum;
-    unsigned int blockOffset;
+    unsigned long fileOffset;
     unsigned int i;
+    unsigned char blockData[512];
 
-    if (DiskImage == NULL) {
+    if (DiskImageHandle == NULL) {
         return; /* No disk image loaded */
     }
 
@@ -315,20 +302,48 @@ void HandleBlockIO (void)
         Error("Block I/O: invalid block number %u (max %u)", blockNum, DiskBlockCount - 1);
     }
 
-    blockOffset = blockNum * 512;
+    /* Calculate file offset (skip .2mg header) */
+    fileOffset = DiskHeaderSize + (blockNum * 512);
 
     if (command == 1) {
         /* Read block */
         Print(stderr, 2, "Block I/O: READ block %u to $%04X\n", blockNum, bufferAddr);
+
+        /* Seek to block position */
+        if (fseek(DiskImageHandle, fileOffset, SEEK_SET) != 0) {
+            Error("Block I/O: seek failed for block %u", blockNum);
+        }
+
+        /* Read block from disk */
+        if (fread(blockData, 1, 512, DiskImageHandle) != 512) {
+            Error("Block I/O: read failed for block %u", blockNum);
+        }
+
+        /* Copy to memory */
         for (i = 0; i < 512; i++) {
-            MemWriteByte(bufferAddr + i, DiskImage[blockOffset + i]);
+            MemWriteByte(bufferAddr + i, blockData[i]);
         }
     } else if (command == 2) {
         /* Write block */
         Print(stderr, 2, "Block I/O: WRITE block %u from $%04X\n", blockNum, bufferAddr);
+
+        /* Copy from memory */
         for (i = 0; i < 512; i++) {
-            DiskImage[blockOffset + i] = MemReadByte(bufferAddr + i);
+            blockData[i] = MemReadByte(bufferAddr + i);
+        }
+
+        /* Seek to block position */
+        if (fseek(DiskImageHandle, fileOffset, SEEK_SET) != 0) {
+            Error("Block I/O: seek failed for block %u", blockNum);
         }
+
+        /* Write block to disk */
+        if (fwrite(blockData, 1, 512, DiskImageHandle) != 512) {
+            Error("Block I/O: write failed for block %u", blockNum);
+        }
+
+        /* Flush to ensure data is written */
+        fflush(DiskImageHandle);
     } else {
         /* Status or unknown command - ignore */
         Print(stderr, 2, "Block I/O: command %u (ignored)\n", command);
-- 
2.43.0

